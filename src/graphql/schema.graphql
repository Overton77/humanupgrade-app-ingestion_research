scalar DateTime
scalar JSON

# ============================================================================
# Enums
# ============================================================================

enum OrgType {
  COMPANY
  NONPROFIT
  RESEARCH_GROUP
  COMMUNITY
  MEDIA_OUTLET
  CLINIC
  FOUNDATION
  REGULATOR
  JOURNAL
  LAB_NETWORK
  DISTRIBUTOR
  MANUFACTURER
  SUPPLIER
  PLATFORM
  OTHER
}

enum BusinessModel {
  B2C
  B2B
  B2B2C
  HYBRID
  UNKNOWN
}

enum LocationType {
  HEADQUARTERS
  REGISTERED_ADDRESS
  OFFICE
  LAB_FACILITY
  CLINIC_SITE
  MANUFACTURING_SITE
  WAREHOUSE
  RETAIL_SITE
  DATA_CENTER
  RESEARCH_SITE
  COLLECTION_SITE
  CONFERENCE_VENUE
  OTHER
}

enum ListingDomain {
  DIAGNOSTICS
  SUPPLEMENT
  DEVICE
  TELEHEALTH
  SOFTWARE
  SERVICE
  OTHER
}

enum PriceType {
  LIST
  PROMO
  MEMBER_ONLY
  INSURANCE_ESTIMATE
  UNKNOWN
}

enum CollectionMode {
  AT_HOME_KIT
  IN_PERSON_DRAW
  MOBILE_PHLEBOTOMY
  IN_CLINIC
  SHIPPING
  TELEHEALTH
  VIRTUAL
  OTHER
}

enum ProductDomain {
  DIAGNOSTICS
  SUPPLEMENT
  DEVICE
  TELEHEALTH
  SOFTWARE
  SERVICE
  OTHER
}

enum ListRole {
  OPERATOR
  PROVIDER
  SELLER
  DISTRIBUTOR
  MARKETER
  FULFILLMENT_PARTNER
  BILLING_ENTITY
  OTHER
}

enum Channel {
  ONLINE
  IN_PERSON
  PHONE
  PARTNER
  MARKETPLACE
  OTHER
}

enum ProcessType {
  chemical_synthesis
  fermentation
  extraction
  semi_synthesis
  formulation
  assembly
  packaging
  qc_release
  other
}

enum ScalabilityLevel {
  lab
  pilot
  commercial
  unknown
}

enum PlatformType {
  THERAPEUTIC_PLATFORM
  DIAGNOSTIC_PLATFORM
  MANUFACTURING_PLATFORM
  MODALITY_PLATFORM
  ANALYTICS_PLATFORM
  OTHER
}

enum RelationshipRole {
  PRIMARY_DEVELOPER
  CO_DEVELOPER
  MAINTAINER
  STEWARD
  UNKNOWN
}

enum UsageContext {
  R_AND_D
  PRODUCTION
  QC
  CLINICAL
  ANALYTICS
  OTHER
  UNKNOWN
}

enum Source {
  CURATED
  IMPORTED
  DERIVED
}

enum ManufacturingRole {
  primary
  subcontractor
  cdmo
  cmo
  api_supplier
  other
}

enum LabTestRole {
  primary
  component
  reflex
  add_on
  eligibility_gate
}

enum PanelRole {
  primary
  variant
  legacy
}

enum CompoundFormRole {
  active
  excipient
  carrier
  other
}

# ============================================================================
# Base Node Types
# ============================================================================

type PhysicalLocation {
  locationId: ID!
  canonicalName: String!
  locationType: LocationType!
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geoLat: Float
  geoLon: Float
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contactPhone: String
  contactEmail: String
}

type Listing {
  listingId: ID!
  listingDomain: ListingDomain!
  title: String!
  description: String
  sku: String
  url: String
  brandName: String
  currency: String!
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

type Product {
  productId: ID!
  name: String!
  synonyms: [String!]
  productDomain: ProductDomain!
  productType: String
  productFingerprint: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime! 

  # Searchability and Vector 

  searchText: String   
  embedding: [Float!] 
  # Relationships
  deliversLabTest: [DeliversLabTestEdge!]
  implementsPanel: [ImplementsPanelEdge!]
  containsCompoundForm: [ContainsCompoundFormEdge!]
  followsPathway: [FollowsPathwayEdge!]
  inCategory: [InCategoryEdge!]
  usesPlatform: [ProductUsesPlatformEdge!]
  hasRegulatoryStatus: [HasRegulatoryStatusEdge!]
  manufacturedBy: [ManufacturedByEdge!]
}

type CompoundForm {
  compoundFormId: ID!
  canonicalName: String!
  formType: String!
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}

type ManufacturingProcess {
  manufacturingProcessId: ID!
  canonicalName: String!
  processType: ProcessType!
  description: String
  inputs: [String!]
  outputs: [String!]
  qualityRisks: [String!]
  scalabilityLevel: ScalabilityLevel
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type TechnologyPlatform {
  platformId: ID!
  canonicalName: String!
  aliases: [String!]
  platformType: PlatformType!
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type LabTest {
  labTestId: ID!
  name: String!
  synonyms: [String!]
  loincCodes: [String!]
  cptCodes: [String!]
  whatItMeasures: String
  prepRequirements: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ProductCategory {
  categoryId: ID!
  name: String!
  description: String
  aliases: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type PanelDefinition {
  panelDefinitionId: ID!
  canonicalName: String!
  aliases: [String!]
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type RegulatoryStatus {
  regulatoryStatusId: ID!
  status: String
  effectiveDate: DateTime
  statusDetails: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type RegulatoryPathway {
  pathwayId: ID!
  authority: String!
  pathwayType: String!
  pathwayName: String!
  requirementsSummary: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

# ============================================================================
# Document Ingestion Types
# ============================================================================

type ResearchPlanRef {
  researchPlanRefId: ID!
  mongoPlanId: String!
  label: String
  version: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ResearchRunRef {
  researchRunRefId: ID!
  mongoRunId: String!
  label: String
  startedAt: DateTime!
  endedAt: DateTime!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  usesPlan: [UsesPlanEdge!]
}

type SearchSurface {
  searchText: String
  searchTextEmbedding: [Float!]
  searchTextModel: String
  searchTextVersion: String
  searchTextUpdatedAt: DateTime
}

type DocumentTextVersion {
  documentTextVersionId: ID!
  textVersionHash: String!
  source: String!
  language: String
  text: String!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  searchText: String
  searchTextEmbedding: [Float!]
  searchTextModel: String
  searchTextVersion: String
  searchTextUpdatedAt: DateTime
  hasSegmentation: [HasSegmentationEdge!]
}

type Segmentation {
  segmentationId: ID!
  segmentationHash: String!
  strategy: String!
  chunkSize: Int!
  overlap: Int!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  hasChunk: [SegmentationHasChunkEdge!]
}

type Chunk {
  chunkId: ID!
  chunkKey: String!
  index: Int!
  text: String!
  charStart: Int
  charEnd: Int
  startMs: Int
  endMs: Int
  embedding: [Float!]
  embeddingModel: String
  embeddingVersion: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  nextChunk: NextChunkEdge
  mentions: [MentionsEdge!]
  about: [AboutEdge!]
}

type Document {
  documentId: ID!
  documentKey: String!
  type: String!
  title: String
  url: String
  publishedAt: DateTime!
  retrievedAt: DateTime!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  searchText: String
  searchTextEmbedding: [Float!]
  searchTextModel: String
  searchTextVersion: String
  searchTextUpdatedAt: DateTime
  hasTextVersion: [HasTextVersionEdge!]
  chunks: [HasChunkEdge!]
  generatedBy: [GeneratedByEdge!]
}

# ============================================================================
# Edge Types (Relationships with Properties)
# ============================================================================

type HasLocationEdge {
  location: PhysicalLocation!
  locationRole: String!
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type OwnsOrControlsEdge {
  organization: Organization!
  relationshipType: String!
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ListsEdge {
  listing: Listing!
  listRole: ListRole!
  channel: Channel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type OffersProductEdge {
  product: Product!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type SuppliesCompoundFormEdge {
  compoundForm: CompoundForm!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ManufacturesEdge {
  compoundForm: CompoundForm!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ManufacturesProductEdge {
  product: Product!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ContractManufacturerForOrganizationEdge {
  organization: Organization!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ContractManufacturerForProductEdge {
  product: Product!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ContractManufacturerForCompoundFormEdge {
  compoundForm: CompoundForm!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type PerformsManufacturingProcessEdge {
  manufacturingProcess: ManufacturingProcess!
  role: ManufacturingRole!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type DevelopsPlatformEdge {
  technologyPlatform: TechnologyPlatform!
  relationshipRole: RelationshipRole
  notes: String
  source: Source
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type UsesPlatformEdge {
  technologyPlatform: TechnologyPlatform!
  usageContext: UsageContext
  isPrimary: Boolean
  notes: String
  source: Source
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type DeliversLabTestEdge {
  labTest: LabTest!
  role: LabTestRole!
  quantity: Int
  componentName: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ImplementsPanelEdge {
  panelDefinition: PanelDefinition!
  panelRole: PanelRole
  versionLabel: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ContainsCompoundFormEdge {
  compoundForm: CompoundForm!
  dose: Float
  doseUnit: String
  role: CompoundFormRole
  standardizedTo: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type FollowsPathwayEdge {
  regulatoryPathway: RegulatoryPathway!
  jurisdictionId: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type InCategoryEdge {
  productCategory: ProductCategory!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ProductUsesPlatformEdge {
  technologyPlatform: TechnologyPlatform!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasRegulatoryStatusEdge {
  regulatoryStatus: RegulatoryStatus!
  status: String
  effectiveDate: DateTime
  statusDetails: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ManufacturedByEdge {
  organization: Organization!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

# Document Ingestion Edge Types

type UsesPlanEdge {
  researchPlanRef: ResearchPlanRef!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasSegmentationEdge {
  segmentation: Segmentation!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type SegmentationHasChunkEdge {
  chunk: Chunk!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type NextChunkEdge {
  chunk: Chunk!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type MentionsEdge {
  # Target node properties will be resolved at query time
  # For now, we include provenance fields that are on the relationship
  confidence: Float
  linkingMethod: String
  surfaceForm: String
  # Provenance fields (also on relationship)
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type AboutEdge {
  # Target node properties will be resolved at query time
  # For now, we include relationship-specific properties
  aboutness: Float
  aspect: String
  stance: String
  # Provenance fields (also on relationship)
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  confidence: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasTextVersionEdge {
  documentTextVersion: DocumentTextVersion!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasChunkEdge {
  chunk: Chunk!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type GeneratedByEdge {
  researchRunRef: ResearchRunRef!
  operation: String!
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

# ============================================================================
# Organization Type
# ============================================================================

type Organization {
  organizationId: ID!
  name: String!
  aliases: [String!]
  orgType: OrgType!
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!] 
  # add isActive or use validAt/invalidAt/expiredAt
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountMin: Int
  employeeCountMax: Int
  employeeCountAsOf: DateTime
  revenueAnnualMin: Float
  revenueAnnualMax: Float
  revenueAnnualCurrency: String
  revenueAnnualAsOf: DateTime
  valuationMin: Float
  valuationMax: Float
  valuationCurrency: String
  valuationAsOf: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime! 

  # Searchability and Vector 
  searchText: String   
  embedding: [Float!] 
  # Relationships
  hasLocation: [HasLocationEdge!]
  ownsOrControls: [OwnsOrControlsEdge!]
  lists: [ListsEdge!]
  offersProduct: [OffersProductEdge!]
  suppliesCompoundForm: [SuppliesCompoundFormEdge!]
  manufactures: [ManufacturesEdge!]
  manufacturesProduct: [ManufacturesProductEdge!]
  contractManufacturerForOrganization: [ContractManufacturerForOrganizationEdge!]
  contractManufacturerForProduct: [ContractManufacturerForProductEdge!]
  contractManufacturerForCompoundForm: [ContractManufacturerForCompoundFormEdge!]
  performsManufacturingProcess: [PerformsManufacturingProcessEdge!]
  developsPlatform: [DevelopsPlatformEdge!]
  usesPlatform: [UsesPlatformEdge!]
}

# ============================================================================
# Input Types
# ============================================================================

input TemporalValidityInput {
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PhysicalLocationInput {
  locationId: ID
  canonicalName: String!
  locationType: LocationType!
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geoLat: Float
  geoLon: Float
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contactPhone: String
  contactEmail: String
}

input ListingInput {
  listingId: ID
  listingDomain: ListingDomain!
  title: String!
  description: String
  sku: String
  url: String
  brandName: String
  currency: String!
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

input ProductInput {
  productId: ID
  name: String!
  synonyms: [String!]
  productDomain: ProductDomain!
  productType: String
  productFingerprint: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  # Relationships
  deliversLabTest: [DeliversLabTestRelationshipInput!]
  implementsPanel: [ImplementsPanelRelationshipInput!]
  containsCompoundForm: [ContainsCompoundFormRelationshipInput!]
  followsPathway: [FollowsPathwayRelationshipInput!]
  inCategory: [InCategoryRelationshipInput!]
  usesPlatform: [ProductUsesPlatformRelationshipInput!]
  hasRegulatoryStatus: [HasRegulatoryStatusRelationshipInput!]
  manufacturedBy: [ManufacturedByRelationshipInput!]
}

input CompoundFormInput {
  compoundFormId: ID
  canonicalName: String!
  formType: String!
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}

input LabTestInput {
  labTestId: ID
  name: String!
  synonyms: [String!]
  loincCodes: [String!]
  cptCodes: [String!]
  whatItMeasures: String
  prepRequirements: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductCategoryInput {
  categoryId: ID
  name: String!
  description: String
  aliases: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PanelDefinitionInput {
  panelDefinitionId: ID
  canonicalName: String!
  aliases: [String!]
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input RegulatoryStatusInput {
  regulatoryStatusId: ID
  status: String
  effectiveDate: DateTime
  statusDetails: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input RegulatoryPathwayInput {
  pathwayId: ID
  authority: String!
  pathwayType: String!
  pathwayName: String!
  requirementsSummary: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# ============================================================================
# Update Input Types (all fields optional for partial updates)
# ============================================================================

input PhysicalLocationUpdateInput {
  locationId: ID
  canonicalName: String
  locationType: LocationType
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geoLat: Float
  geoLon: Float
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contactPhone: String
  contactEmail: String
}

input ListingUpdateInput {
  listingId: ID
  listingDomain: ListingDomain
  title: String
  description: String
  sku: String
  url: String
  brandName: String
  currency: String
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

input ProductUpdateInput {
  productId: ID
  name: String
  synonyms: [String!]
  productDomain: ProductDomain
  productType: String
  productFingerprint: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  # Relationships (using update versions)
  deliversLabTest: [DeliversLabTestRelationshipUpdateInput!]
  implementsPanel: [ImplementsPanelRelationshipUpdateInput!]
  containsCompoundForm: [ContainsCompoundFormRelationshipUpdateInput!]
  followsPathway: [FollowsPathwayRelationshipUpdateInput!]
  inCategory: [InCategoryRelationshipUpdateInput!]
  usesPlatform: [ProductUsesPlatformRelationshipUpdateInput!]
  hasRegulatoryStatus: [HasRegulatoryStatusRelationshipUpdateInput!]
  manufacturedBy: [ManufacturedByRelationshipUpdateInput!]
}

input CompoundFormUpdateInput {
  compoundFormId: ID
  canonicalName: String
  formType: String
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}

input LabTestUpdateInput {
  labTestId: ID
  name: String
  synonyms: [String!]
  loincCodes: [String!]
  cptCodes: [String!]
  whatItMeasures: String
  prepRequirements: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductCategoryUpdateInput {
  categoryId: ID
  name: String
  description: String
  aliases: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PanelDefinitionUpdateInput {
  panelDefinitionId: ID
  canonicalName: String
  aliases: [String!]
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input RegulatoryStatusUpdateInput {
  regulatoryStatusId: ID
  status: String
  effectiveDate: DateTime
  statusDetails: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input RegulatoryPathwayUpdateInput {
  pathwayId: ID
  authority: String
  pathwayType: String
  pathwayName: String
  requirementsSummary: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturingProcessInput {
  manufacturingProcessId: ID
  canonicalName: String!
  processType: ProcessType!
  description: String
  inputs: [String!]
  outputs: [String!]
  qualityRisks: [String!]
  scalabilityLevel: ScalabilityLevel
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturingProcessUpdateInput {
  manufacturingProcessId: ID
  canonicalName: String
  processType: ProcessType
  description: String
  inputs: [String!]
  outputs: [String!]
  qualityRisks: [String!]
  scalabilityLevel: ScalabilityLevel
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input TechnologyPlatformInput {
  platformId: ID
  canonicalName: String!
  aliases: [String!]
  platformType: PlatformType!
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input TechnologyPlatformUpdateInput {
  platformId: ID
  canonicalName: String
  aliases: [String!]
  platformType: PlatformType
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# ============================================================================
# Document Ingestion Input Types
# ============================================================================

input UpsertResearchPlanRefInput {
  mongoPlanId: String!
  label: String
  version: String
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UpsertResearchRunRefInput {
  mongoRunId: String!
  label: String
  startedAt: DateTime
  endedAt: DateTime
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input LinkResearchRunUsesPlanInput {
  mongoRunId: String!
  mongoPlanId: String!
  validAt: DateTime
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input DocumentGeneratedByInput {
  mongoRunId: String!
  operation: String!
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime
  validAt: DateTime
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input InlineChunkBundleSyntheticInput {
  source: String
  strategy: String
  chunkSize: Int
  overlap: Int
}

input InlineChunkBundleInput {
  textVersion: DocumentTextVersionInput
  segmentation: SegmentationInput
  chunks: [ChunkInput!]!
  hasTextVersionEdge: TemporalValidityInput
  hasSegmentationEdge: TemporalValidityInput
  segmentationHasChunkEdge: TemporalValidityInput
  documentHasChunkEdge: TemporalValidityInput
  nextChunkEdge: TemporalValidityInput
  alsoCreateDocumentHasChunkEdges: Boolean = true
  alsoCreateNextChunkEdges: Boolean = true
  synthetic: InlineChunkBundleSyntheticInput
}

input SearchSurfaceInput {
  searchText: String
  searchTextEmbedding: [Float!]
  searchTextModel: String
  searchTextVersion: String
  searchTextUpdatedAt: DateTime
}

input UpsertDocumentInput {
  documentKey: String!
  type: String!
  title: String
  url: String
  publishedAt: DateTime
  retrievedAt: DateTime
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  searchSurface: SearchSurfaceInput
  generatedBy: DocumentGeneratedByInput
  chunkBundle: InlineChunkBundleInput
}

input DocumentTextVersionInput {
  textVersionHash: String!
  source: String!
  language: String
  text: String!
  searchSurface: SearchSurfaceInput
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input SegmentationInput {
  segmentationHash: String!
  strategy: String!
  chunkSize: Int!
  overlap: Int!
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ChunkInput {
  chunkKey: String!
  index: Int!
  text: String!
  charStart: Int
  charEnd: Int
  startMs: Int
  endMs: Int
  embedding: [Float!]
  embeddingModel: String
  embeddingVersion: String
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UpsertDocumentTextVersionBundleInput {
  documentId: String!
  textVersion: DocumentTextVersionInput!
  segmentation: SegmentationInput!
  chunks: [ChunkInput!]!
  hasTextVersionEdge: TemporalValidityInput
  hasSegmentationEdge: TemporalValidityInput
  segmentationHasChunkEdge: TemporalValidityInput
  documentHasChunkEdge: TemporalValidityInput
  nextChunkEdge: TemporalValidityInput
  alsoCreateDocumentHasChunkEdges: Boolean = true
  alsoCreateNextChunkEdges: Boolean = true
}

# ============================================================================
# Evidence Edge Types - Linking Documents/Chunks to Entities
# ============================================================================

enum EvidenceEdgeType {
  ABOUT
  MENTIONS
  IS_PRIMARY_SOURCE
}

# ============================================================================
# Evidence Provenance Input
# ============================================================================

input EvidenceProvenanceInput {
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
}

# ============================================================================
# Evidence Source Reference Input (Discriminated Union)
# ============================================================================

input EvidenceSourceRefInput {
  kind: EvidenceSourceKind!
  # For kind="Document", provide documentId
  documentId: String
  # For kind="Chunk", provide chunkId
  chunkId: String
}

enum EvidenceSourceKind {
  Document
  Chunk
}

# ============================================================================
# Evidence Target Reference Input
# ============================================================================
# Prefer nodeId; allow fallback resolution using label + uniqueKey + uniqueKeyValue

input EvidenceTargetRefInput {
  nodeId: String
  
  # Fallback fields (only used if nodeId is missing)
  label: String
  uniqueKey: String
  uniqueKeyValue: String
}

# ============================================================================
# Evidence Edge Property Inputs
# ============================================================================

input AboutEdgePropsInput {
  # Temporal validity fields
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  
  # Provenance fields
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  
  # About-specific fields
  aboutness: Float
  aspect: String
  stance: String
  confidence: Float
}

input MentionsEdgePropsInput {
  # Temporal validity fields
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  
  # Provenance fields
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  
  # Mentions-specific fields
  confidence: Float
  linkingMethod: String
  surfaceForm: String
  charStart: Int
  charEnd: Int
}

input IsPrimarySourceEdgePropsInput {
  # Temporal validity fields
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  
  # Provenance fields
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  
  # IS_PRIMARY_SOURCE-specific fields
  confidence: Float
  notes: String
}

# ============================================================================
# Evidence Edge Input Types
# ============================================================================
# Note: GraphQL doesn't support union input types, so we use a flattened discriminated union pattern.
# The resolver should validate that the correct fields are provided based on the "type" field.
# All edge-specific property fields are flattened into EvidenceEdgeInput for simplicity.

input EvidenceEdgeInput {
  type: EvidenceEdgeType!
  source: EvidenceSourceRefInput!
  target: EvidenceTargetRefInput!
  
  # Temporal validity fields (common to all edge types)
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  
  # Provenance fields (common to all edge types)
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  
  # ABOUT edge specific fields (used when type="ABOUT")
  aboutness: Float
  aspect: String
  stance: String
  
  # MENTIONS edge specific fields (used when type="MENTIONS")
  linkingMethod: String
  surfaceForm: String
  charStart: Int
  charEnd: Int
  
  # IS_PRIMARY_SOURCE edge specific fields (used when type="IS_PRIMARY_SOURCE")
  notes: String
  
  # Confidence (used by ABOUT, MENTIONS, and IS_PRIMARY_SOURCE)
  confidence: Float
}

input UpsertEvidenceEdgesInput {
  edges: [EvidenceEdgeInput!]!
}

# ============================================================================
# Evidence Edge Result Types
# ============================================================================

# Union type for source reference result (GraphQL supports union types for outputs)
union EvidenceSourceRefResult = EvidenceSourceRefDocumentResult | EvidenceSourceRefChunkResult

type EvidenceSourceRefDocumentResult {
  kind: EvidenceSourceKind! # Always "Document"
  documentId: String!
}

type EvidenceSourceRefChunkResult {
  kind: EvidenceSourceKind! # Always "Chunk"
  chunkId: String!
}

type EvidenceTargetRefResolved {
  nodeId: String!
  label: String!
  uniqueKey: String
  uniqueKeyValue: String
}

type UpsertEvidenceEdgeResult {
  ok: Boolean! # Always true for successful results
  edgeType: EvidenceEdgeType!
  relKey: String!
  relationshipId: String
  
  source: EvidenceSourceRefResult!
  target: EvidenceTargetRefResolved!
  
  created: Boolean!
  updated: Boolean!
}

type UpsertEvidenceEdgeError {
  index: Int!
  edgeType: EvidenceEdgeType
  message: String!
  code: String
}

type UpsertEvidenceEdgesCounts {
  received: Int!
  attempted: Int!
  created: Int!
  updated: Int!
  failed: Int!
}

type UpsertEvidenceEdgesResult {
  ok: Boolean!
  counts: UpsertEvidenceEdgesCounts!
  results: [UpsertEvidenceEdgeResult!]!
  errors: [UpsertEvidenceEdgeError!]!
}

# Relationship Inputs with nested create/connect/update
# Note: GraphQL doesn't support union types for inputs, so we use optional fields
# Resolvers should validate that exactly one of create/connect is provided

input PhysicalLocationRelateInput {
  create: PhysicalLocationInput
  connect: PhysicalLocationConnectInput
}

input PhysicalLocationRelateUpdateInput {
  create: PhysicalLocationInput
  connect: PhysicalLocationConnectInput
  update: PhysicalLocationUpdateInput
}

input PhysicalLocationConnectInput {
  locationId: ID!
}

input HasLocationRelationshipInput {
  location: PhysicalLocationRelateInput!
  locationRole: String!
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasLocationRelationshipUpdateInput {
  location: PhysicalLocationRelateUpdateInput!
  locationRole: String
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OrganizationRelateInput {
  create: OrganizationInput
  connect: OrganizationConnectInput
}

input OrganizationRelateUpdateInput {
  create: OrganizationInput
  connect: OrganizationConnectInput
  update: UpdateOrganizationInput
}

input OrganizationConnectInput {
  organizationId: ID!
}

input OwnsOrControlsRelationshipInput {
  organization: OrganizationRelateInput!
  relationshipType: String!
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OwnsOrControlsRelationshipUpdateInput {
  organization: OrganizationRelateUpdateInput!
  relationshipType: String
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ListingRelateInput {
  create: ListingInput
  connect: ListingConnectInput
}

input ListingRelateUpdateInput {
  create: ListingInput
  connect: ListingConnectInput
  update: ListingUpdateInput
}

input ListingConnectInput {
  listingId: ID!
}

input ListsRelationshipInput {
  listing: ListingRelateInput!
  listRole: ListRole!
  channel: Channel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ListsRelationshipUpdateInput {
  listing: ListingRelateUpdateInput!
  listRole: ListRole
  channel: Channel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductRelateInput {
  create: ProductInput
  connect: ProductConnectInput
}

input ProductRelateUpdateInput {
  create: ProductInput
  connect: ProductConnectInput
  update: ProductUpdateInput
}

input ProductConnectInput {
  productId: ID!
}

input LabTestRelateInput {
  create: LabTestInput
  connect: LabTestConnectInput
}

input LabTestRelateUpdateInput {
  create: LabTestInput
  connect: LabTestConnectInput
  update: LabTestUpdateInput
}

input LabTestConnectInput {
  labTestId: ID!
}

input ProductCategoryRelateInput {
  create: ProductCategoryInput
  connect: ProductCategoryConnectInput
}

input ProductCategoryRelateUpdateInput {
  create: ProductCategoryInput
  connect: ProductCategoryConnectInput
  update: ProductCategoryUpdateInput
}

input ProductCategoryConnectInput {
  categoryId: ID!
}

input PanelDefinitionRelateInput {
  create: PanelDefinitionInput
  connect: PanelDefinitionConnectInput
}

input PanelDefinitionRelateUpdateInput {
  create: PanelDefinitionInput
  connect: PanelDefinitionConnectInput
  update: PanelDefinitionUpdateInput
}

input PanelDefinitionConnectInput {
  panelDefinitionId: ID!
}

input RegulatoryStatusRelateInput {
  create: RegulatoryStatusInput
  connect: RegulatoryStatusConnectInput
}

input RegulatoryStatusRelateUpdateInput {
  create: RegulatoryStatusInput
  connect: RegulatoryStatusConnectInput
  update: RegulatoryStatusUpdateInput
}

input RegulatoryStatusConnectInput {
  regulatoryStatusId: ID!
}

input RegulatoryPathwayRelateInput {
  create: RegulatoryPathwayInput
  connect: RegulatoryPathwayConnectInput
}

input RegulatoryPathwayRelateUpdateInput {
  create: RegulatoryPathwayInput
  connect: RegulatoryPathwayConnectInput
  update: RegulatoryPathwayUpdateInput
}

input RegulatoryPathwayConnectInput {
  pathwayId: ID!
}

input OffersProductRelationshipInput {
  product: ProductRelateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OffersProductRelationshipUpdateInput {
  product: ProductRelateUpdateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input CompoundFormRelateInput {
  create: CompoundFormInput
  connect: CompoundFormConnectInput
}

input CompoundFormRelateUpdateInput {
  create: CompoundFormInput
  connect: CompoundFormConnectInput
  update: CompoundFormUpdateInput
}

input CompoundFormConnectInput {
  compoundFormId: ID!
}

input SuppliesCompoundFormRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input SuppliesCompoundFormRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturingProcessRelateInput {
  create: ManufacturingProcessInput
  connect: ManufacturingProcessConnectInput
}

input ManufacturingProcessRelateUpdateInput {
  create: ManufacturingProcessInput
  connect: ManufacturingProcessConnectInput
  update: ManufacturingProcessUpdateInput
}

input ManufacturingProcessConnectInput {
  manufacturingProcessId: ID!
}

input TechnologyPlatformRelateInput {
  create: TechnologyPlatformInput
  connect: TechnologyPlatformConnectInput
}

input TechnologyPlatformRelateUpdateInput {
  create: TechnologyPlatformInput
  connect: TechnologyPlatformConnectInput
  update: TechnologyPlatformUpdateInput
}

input TechnologyPlatformConnectInput {
  platformId: ID!
}

input ManufacturesRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturesRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturesProductRelationshipInput {
  product: ProductRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturesProductRelationshipUpdateInput {
  product: ProductRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForOrganizationRelationshipInput {
  organization: OrganizationRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForOrganizationRelationshipUpdateInput {
  organization: OrganizationRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForProductRelationshipInput {
  product: ProductRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForProductRelationshipUpdateInput {
  product: ProductRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForCompoundFormRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForCompoundFormRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PerformsManufacturingProcessRelationshipInput {
  manufacturingProcess: ManufacturingProcessRelateInput!
  role: ManufacturingRole!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PerformsManufacturingProcessRelationshipUpdateInput {
  manufacturingProcess: ManufacturingProcessRelateUpdateInput!
  role: ManufacturingRole
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DevelopsPlatformRelationshipInput {
  technologyPlatform: TechnologyPlatformRelateInput!
  relationshipRole: RelationshipRole
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DevelopsPlatformRelationshipUpdateInput {
  technologyPlatform: TechnologyPlatformRelateUpdateInput!
  relationshipRole: RelationshipRole
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input UsesPlatformRelationshipInput {
  technologyPlatform: TechnologyPlatformRelateInput!
  usageContext: UsageContext
  isPrimary: Boolean
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input UsesPlatformRelationshipUpdateInput {
  technologyPlatform: TechnologyPlatformRelateUpdateInput!
  usageContext: UsageContext
  isPrimary: Boolean
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DeliversLabTestRelationshipInput {
  labTest: LabTestRelateInput!
  role: LabTestRole!
  quantity: Int
  componentName: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DeliversLabTestRelationshipUpdateInput {
  labTest: LabTestRelateUpdateInput!
  role: LabTestRole
  quantity: Int
  componentName: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ImplementsPanelRelationshipInput {
  panelDefinition: PanelDefinitionRelateInput!
  panelRole: PanelRole
  versionLabel: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ImplementsPanelRelationshipUpdateInput {
  panelDefinition: PanelDefinitionRelateUpdateInput!
  panelRole: PanelRole
  versionLabel: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContainsCompoundFormRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  dose: Float
  doseUnit: String
  role: CompoundFormRole
  standardizedTo: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContainsCompoundFormRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  dose: Float
  doseUnit: String
  role: CompoundFormRole
  standardizedTo: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input FollowsPathwayRelationshipInput {
  regulatoryPathway: RegulatoryPathwayRelateInput!
  jurisdictionId: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input FollowsPathwayRelationshipUpdateInput {
  regulatoryPathway: RegulatoryPathwayRelateUpdateInput!
  jurisdictionId: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input InCategoryRelationshipInput {
  productCategory: ProductCategoryRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input InCategoryRelationshipUpdateInput {
  productCategory: ProductCategoryRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductUsesPlatformRelationshipInput {
  technologyPlatform: TechnologyPlatformRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductUsesPlatformRelationshipUpdateInput {
  technologyPlatform: TechnologyPlatformRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasRegulatoryStatusRelationshipInput {
  regulatoryStatus: RegulatoryStatusRelateInput!
  status: String
  effectiveDate: DateTime
  statusDetails: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
input HasRegulatoryStatusRelationshipUpdateInput {
  regulatoryStatus: RegulatoryStatusRelateUpdateInput!
  status: String
  effectiveDate: DateTime
  statusDetails: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturedByRelationshipInput {
  organization: OrganizationRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturedByRelationshipUpdateInput {
  organization: OrganizationRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OrganizationInput {
  organizationId: ID
  name: String!
  aliases: [String!]
  orgType: OrgType!
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!]
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountMin: Int
  employeeCountMax: Int
  employeeCountAsOf: DateTime
  revenueAnnualMin: Float
  revenueAnnualMax: Float
  revenueAnnualCurrency: String
  revenueAnnualAsOf: DateTime
  valuationMin: Float
  valuationMax: Float
  valuationCurrency: String
  valuationAsOf: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  # Relationships
  hasLocation: [HasLocationRelationshipInput!]
  ownsOrControls: [OwnsOrControlsRelationshipInput!]
  lists: [ListsRelationshipInput!]
  offersProduct: [OffersProductRelationshipInput!]
  suppliesCompoundForm: [SuppliesCompoundFormRelationshipInput!]
  manufactures: [ManufacturesRelationshipInput!]
  manufacturesProduct: [ManufacturesProductRelationshipInput!]
  contractManufacturerForOrganization: [ContractManufacturerForOrganizationRelationshipInput!]
  contractManufacturerForProduct: [ContractManufacturerForProductRelationshipInput!]
  contractManufacturerForCompoundForm: [ContractManufacturerForCompoundFormRelationshipInput!]
  performsManufacturingProcess: [PerformsManufacturingProcessRelationshipInput!]
  developsPlatform: [DevelopsPlatformRelationshipInput!]
  usesPlatform: [UsesPlatformRelationshipInput!]
}

input UpdateOrganizationInput {
  organizationId: ID
  name: String
  aliases: [String!]
  orgType: OrgType
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!]
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountMin: Int
  employeeCountMax: Int
  employeeCountAsOf: DateTime
  revenueAnnualMin: Float
  revenueAnnualMax: Float
  revenueAnnualCurrency: String
  revenueAnnualAsOf: DateTime
  valuationMin: Float
  valuationMax: Float
  valuationCurrency: String
  valuationAsOf: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  # Relationships (using update versions)
  hasLocation: [HasLocationRelationshipUpdateInput!]
  ownsOrControls: [OwnsOrControlsRelationshipUpdateInput!]
  lists: [ListsRelationshipUpdateInput!]
  offersProduct: [OffersProductRelationshipUpdateInput!]
  suppliesCompoundForm: [SuppliesCompoundFormRelationshipUpdateInput!]
  manufactures: [ManufacturesRelationshipUpdateInput!]
  manufacturesProduct: [ManufacturesProductRelationshipUpdateInput!]
  contractManufacturerForOrganization: [ContractManufacturerForOrganizationRelationshipUpdateInput!]
  contractManufacturerForProduct: [ContractManufacturerForProductRelationshipUpdateInput!]
  contractManufacturerForCompoundForm: [ContractManufacturerForCompoundFormRelationshipUpdateInput!]
  performsManufacturingProcess: [PerformsManufacturingProcessRelationshipUpdateInput!]
  developsPlatform: [DevelopsPlatformRelationshipUpdateInput!]
  usesPlatform: [UsesPlatformRelationshipUpdateInput!]
}  



# ============================================================================
# Search Input Types
# ============================================================================   

"""
Which retrieval strategy to use.
- FIELD_ONLY: filters/sorts only (no q ranking)
- FULLTEXT_ONLY: lexical match via Neo4j fulltext index
- VECTOR_ONLY: semantic match via Neo4j vector index
- HYBRID: combines FULLTEXT + VECTOR (recommended default)
"""
enum SearchMode {
  FIELD_ONLY
  FULLTEXT_ONLY
  VECTOR_ONLY
  HYBRID
}

"""
Cursor pagination input.

Use `after` to fetch the next page.
`first` should be small-ish (10-50) for ranked search.
"""
input PageInput {
  first: Int! = 20
  after: String
}

"""
Standard page info for cursor pagination.
"""
type PageInfo {
  hasNextPage: Boolean!
  endCursor: String
}

# ----------------------------------------------------------------------------
# Explainable scoring
# ----------------------------------------------------------------------------

enum SearchReasonKind {
  FULLTEXT_MATCH
  VECTOR_MATCH
  EXACT_MATCH
  FILTER_APPLIED
  BOOST_APPLIED
}

type SearchReason {
  kind: SearchReasonKind!
  field: String
  value: String
  score: Float
  detail: String
}

# ----------------------------------------------------------------------------
# Organization Search
# ----------------------------------------------------------------------------

input OrganizationFilterInput {
  orgTypeIn: [OrgType!]
  businessModelIn: [BusinessModel!]

  regionsServedAny: [String!]
  primaryIndustryTagsAny: [String!]

  publicTicker: String

  employeeCountMinGte: Int
  employeeCountMaxLte: Int

  """
  Optional: if you materialize isActive on the node.
  If you don't store it yet, ignore this field in resolvers (or treat null as no-op).
  """
  isActive: Boolean
}

enum OrganizationSortField {
  NAME
  CREATED_AT
  EMPLOYEE_COUNT_MIN
  EMPLOYEE_COUNT_MAX
}

enum SortDirection {
  ASC
  DESC
}

input OrganizationSortInput {
  field: OrganizationSortField!
  direction: SortDirection! = DESC
}

input OrganizationSearchInput {
  """
  Query text. If omitted/empty, FIELD_ONLY mode is usually used.
  """
  q: String

  mode: SearchMode = HYBRID

  filter: OrganizationFilterInput

  """
  Sort is only guaranteed to be respected when mode=FIELD_ONLY or q is empty.
  Ranked modes (FULLTEXT/VECTOR/HYBRID) primarily sort by score.
  """
  sort: OrganizationSortInput

  page: PageInput = { first: 20 }

  """
  When true, return score reasons (why it matched).
  Off by default to keep responses small/fast.
  """
  explain: Boolean = false
}

type OrganizationSearchHit {
  node: Organization!
  score: Float
  reasons: [SearchReason!]
}

type OrganizationSearchResult {
  items: [OrganizationSearchHit!]!
  pageInfo: PageInfo!
}

# ----------------------------------------------------------------------------
# Product Search
# ----------------------------------------------------------------------------

input ProductFilterInput {
  productDomainIn: [ProductDomain!]
  riskClassIn: [String!]

  currency: String
  priceAmountGte: Float
  priceAmountLte: Float

  # Identifier exact matches
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String

  isActive: Boolean
}

enum ProductSortField {
  NAME
  CREATED_AT
  PRICE_AMOUNT
}

input ProductSortInput {
  field: ProductSortField!
  direction: SortDirection! = DESC
}

input ProductSearchInput {
  q: String
  mode: SearchMode = HYBRID

  filter: ProductFilterInput
  sort: ProductSortInput

  page: PageInput = { first: 20 }
  explain: Boolean = false
}

type ProductSearchHit {
  node: Product!
  score: Float
  reasons: [SearchReason!]
}

type ProductSearchResult {
  items: [ProductSearchHit!]!
  pageInfo: PageInfo!
}

# ----------------------------------------------------------------------------
# Autocomplete
# ----------------------------------------------------------------------------

enum AutocompleteEntityType {
  ORGANIZATION
  PRODUCT
}

type AutocompleteItem {
  id: ID!
  label: String!
  subtitle: String
} 

# ----------------------------------------------------------------------------
# Embedding
# ----------------------------------------------------------------------------

enum EmbeddingTargetType {
  ORGANIZATION
  PRODUCT  
  # Add All Other Types that have embeddings on their searchText or other fields 
} 

enum EmbeddingJobStatus {
  QUEUED
  RUNNING
  COMPLETE
  SKIPPED
  FAILED
}
 



input UpsertEmbeddingInput {
  targetType: EmbeddingTargetType!
  targetId: ID! 

  # Optional: let you override rules (rarely used)
  force: Boolean = false 

  requestId: String 
}

type UpsertEmbeddingResult {
  targetType: EmbeddingTargetType!
  targetId: ID!
  status: EmbeddingJobStatus!
  message: String 
  jobId: String 
} 

type EmbeddingJobEvent {
  targetType: EmbeddingTargetType!
  targetId: ID!
  status: EmbeddingJobStatus!
  jobId: String
  requestId: String
  message: String
  error: String
  updatedAt: DateTime!
} 


type UpsertDocumentTextVersionBundleResult {
  documentId: String!
  documentTextVersionId: String!
  segmentationId: String!
  chunkMetas: [ChunkMeta!]!
  nextChunkEdgesCreated: Boolean!
}

type ChunkMeta {
  chunkId: String!
  chunkKey: String!
  index: Int!
}

# ============================================================================
# Query & Mutation
# ============================================================================

type Query {
  organizations: [Organization!]! 
  products: [Product!]! 
  searchOrganizations(input: OrganizationSearchInput!): OrganizationSearchResult!
  # searchProducts(input: ProductSearchInput!): ProductSearchResult! 
  #   autocompleteOrganizations(q: String!, first: Int = 10): [AutocompleteItem!]!
  # autocompleteProducts(q: String!, first: Int = 10): [AutocompleteItem!]!
}

type Mutation {
  createOrganization(input: OrganizationInput!): Organization!
  updateOrganization(input: UpdateOrganizationInput!): Organization!
  createProduct(input: ProductInput!): Product!
  updateProduct(input: ProductUpdateInput!): Product! 
  upsertEmbedding(input: UpsertEmbeddingInput!): UpsertEmbeddingResult! 
  upsertEmbeddings(inputs: [UpsertEmbeddingInput!]!): [UpsertEmbeddingResult!]!  
  upsertResearchPlanRef(input: UpsertResearchPlanRefInput!): ResearchPlanRef! 
  upsertResearchRunRef(input: UpsertResearchRunRefInput!): ResearchRunRef!  
  linkResearchRunUsesPlan(input: LinkResearchRunUsesPlanInput!): ResearchRunRef! 
  upsertDocument(input: UpsertDocumentInput!): Document!   
  upsertDocumentTextVersionBundle(input: UpsertDocumentTextVersionBundleInput!): UpsertDocumentTextVersionBundleResult! 
  upsertEvidenceEdge(input: EvidenceEdgeInput!): UpsertEvidenceEdgeResult!
  upsertEvidenceEdges(input: [UpsertEvidenceEdgesInput!]!): [UpsertEvidenceEdgesResult!]!
}


type Subscription { 
  embeddingJobEvents(targetType: EmbeddingTargetType!, targetID: ID): EmbeddingJobEvent! 
  documentIngested(documentId: String): Document! 
  documentTextVersionBundleIngested(documentTextVersionId: String): UpsertDocumentTextVersionBundleResult! 
  evidenceEdgeUpserted(relKey: String): UpsertEvidenceEdgeResult!   
 
}
